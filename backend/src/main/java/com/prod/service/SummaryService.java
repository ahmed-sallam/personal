package com.prod.service;

import com.prod.dto.response.SummaryResponse;
import com.prod.entity.AISummary;
import com.prod.entity.AudioRecord;
import com.prod.entity.User;
import com.prod.repository.AISummaryRepository;
import com.prod.repository.AudioRecordRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

/**
 * Service for managing AI-generated summaries.
 *
 * This service provides business logic for retrieving AI summaries and their
 * associated action items. All operations are scoped to the authenticated user
 * to ensure proper data isolation.
 *
 * Key Features:
 * - User isolation: Users can only access their own summaries
 * - Pagination support: Efficient retrieval of large summary lists
 * - Action item integration: Summaries include associated action items
 * - Transaction management: Read-only operations use read-only transactions
 *
 * Security:
 * - All methods require valid Authentication object from JWT
 * - User ID is extracted from JWT token via authentication.getName()
 * - Database queries filter by user_id to prevent cross-user access
 *
 * @see com.prod.entity.AISummary
 * @see com.prod.repository.AISummaryRepository
 * @see com.prod.dto.response.SummaryResponse
 */
@Service
@Slf4j
@RequiredArgsConstructor
public class SummaryService {

    private final AISummaryRepository aiSummaryRepository;
    private final AudioRecordRepository audioRecordRepository;

    /**
     * Get all summaries for the authenticated user with pagination.
     *
     * This method retrieves all AI summaries associated with audio records
     * owned by the authenticated user. Results are paginated for efficient
     * retrieval and ordered by creation date (newest first).
     *
     * The method joins through audio_records to ensure user isolation:
     * summaries → audio_record → user
     *
     * @param authentication the Spring Security authentication object (from JWT)
     * @param pageable pagination parameters (page, size, sort)
     * @return Page of SummaryResponse DTOs
     * @throws IllegalArgumentException if authentication is null or invalid
     *
     * Example usage:
     * <pre>
     * Pageable pageable = PageRequest.of(0, 20, Sort.by("createdAt").descending());
     * Page<SummaryResponse> summaries = summaryService.getSummariesForUser(authentication, pageable);
     * </pre>
     */
    @Transactional(readOnly = true)
    public Page<SummaryResponse> getSummariesForUser(Authentication authentication, Pageable pageable) {
        if (authentication == null || authentication.getName() == null) {
            log.warn("Attempted to get summaries with null authentication");
            throw new IllegalArgumentException("Authentication cannot be null");
        }

        UUID userId = UUID.fromString(authentication.getName());
        log.info("Retrieving summaries for user: {}", userId);

        // Query summaries through audio records to ensure user isolation
        Page<AISummary> summaries = aiSummaryRepository.findByUserId(userId, pageable);

        log.info("Found {} summaries for user: {}", summaries.getTotalElements(), userId);

        // Convert entities to DTOs
        return summaries.map(this::mapToResponse);
    }

    /**
     * Get a specific summary by ID for the authenticated user.
     *
     * This method retrieves a single AI summary by its ID, but only if it
     * belongs to an audio record owned by the authenticated user. This prevents
     * users from accessing summaries generated by other users.
     *
     * @param id the summary ID
     * @param authentication the Spring Security authentication object (from JWT)
     * @return SummaryResponse DTO
     * @throws IllegalArgumentException if authentication is null or invalid
     * @throws SecurityException if summary doesn't exist or doesn't belong to user
     */
    @Transactional(readOnly = true)
    public SummaryResponse getSummaryById(UUID id, Authentication authentication) {
        if (authentication == null || authentication.getName() == null) {
            log.warn("Attempted to get summary with null authentication");
            throw new IllegalArgumentException("Authentication cannot be null");
        }

        UUID userId = UUID.fromString(authentication.getName());
        log.info("Retrieving summary: {} for user: {}", id, userId);

        AISummary summary = aiSummaryRepository.findById(id)
                .orElseThrow(() -> {
                    log.warn("Summary not found: {}", id);
                    return new IllegalArgumentException("Summary not found: " + id);
                });

        // Verify user owns this summary (through audio record)
        if (!summary.getAudioRecord().getUser().getId().equals(userId)) {
            log.warn("User {} attempted to access summary {} owned by user {}",
                    userId, id, summary.getAudioRecord().getUser().getId());
            throw new SecurityException("Access denied: summary does not belong to this user");
        }

        log.info("Summary retrieved successfully: {}", id);
        return mapToResponse(summary);
    }

    /**
     * Get summary by audio record ID for the authenticated user.
     *
     * This is a convenience method to retrieve the summary for a specific
     * audio record. It verifies that both the audio record and summary exist
     * and belong to the authenticated user.
     *
     * @param audioRecordId the audio record ID
     * @param authentication the Spring Security authentication object (from JWT)
     * @return SummaryResponse DTO, or null if no summary exists yet
     * @throws IllegalArgumentException if authentication is null or invalid
     * @throws SecurityException if audio record doesn't belong to user
     */
    @Transactional(readOnly = true)
    public SummaryResponse getSummaryByAudioRecordId(UUID audioRecordId, Authentication authentication) {
        if (authentication == null || authentication.getName() == null) {
            log.warn("Attempted to get summary with null authentication");
            throw new IllegalArgumentException("Authentication cannot be null");
        }

        UUID userId = UUID.fromString(authentication.getName());
        log.info("Retrieving summary for audio record: {} by user: {}", audioRecordId, userId);

        // Verify user owns the audio record
        AudioRecord audioRecord = audioRecordRepository.findById(audioRecordId)
                .orElseThrow(() -> {
                    log.warn("Audio record not found: {}", audioRecordId);
                    return new IllegalArgumentException("Audio record not found: " + audioRecordId);
                });

        if (!audioRecord.getUser().getId().equals(userId)) {
            log.warn("User {} attempted to access audio record {} owned by user {}",
                    userId, audioRecordId, audioRecord.getUser().getId());
            throw new SecurityException("Access denied: audio record does not belong to this user");
        }

        // Get summary for this audio record
        return aiSummaryRepository.findByAudioRecord(audioRecord)
                .map(this::mapToResponse)
                .orElse(null);
    }

    /**
     * Get all summaries with a specific category for the authenticated user.
     *
     * This method filters summaries by category field in the structured_data
     * JSONB column. Uses PostgreSQL's JSONB querying capabilities for
     * efficient filtering.
     *
     * @param category the category to filter by (e.g., "meeting", "work", "personal")
     * @param authentication the Spring Security authentication object (from JWT)
     * @param pageable pagination parameters
     * @return Page of SummaryResponse DTOs matching the category
     */
    @Transactional(readOnly = true)
    public Page<SummaryResponse> getSummariesByCategory(String category, Authentication authentication, Pageable pageable) {
        if (authentication == null || authentication.getName() == null) {
            log.warn("Attempted to get summaries with null authentication");
            throw new IllegalArgumentException("Authentication cannot be null");
        }

        UUID userId = UUID.fromString(authentication.getName());
        log.info("Retrieving summaries for category: {} by user: {}", category, userId);

        // This would require a custom query in AISummaryRepository
        // For now, return empty page as this is a placeholder for future enhancement
        log.debug("Category filtering not yet implemented, returning empty results");
        return Page.empty();
    }

    /**
     * Count total summaries for the authenticated user.
     *
     * Utility method for dashboard statistics and pagination metadata.
     *
     * @param authentication the Spring Security authentication object (from JWT)
     * @return total count of summaries for the user
     */
    @Transactional(readOnly = true)
    public long countSummariesForUser(Authentication authentication) {
        if (authentication == null || authentication.getName() == null) {
            log.warn("Attempted to count summaries with null authentication");
            throw new IllegalArgumentException("Authentication cannot be null");
        }

        UUID userId = UUID.fromString(authentication.getName());

        // Count summaries through audio records for user isolation
        // Use a small page size to count efficiently
        long count = aiSummaryRepository.findByUserId(
                userId,
                org.springframework.data.domain.PageRequest.of(0, 1)
        ).getTotalElements();

        log.info("User {} has {} summaries", userId, count);
        return count;
    }

    /**
     * Map AISummary entity to SummaryResponse DTO.
     *
     * Private helper method to convert entity to response DTO.
     * Includes all fields and preserves the structured data JSON.
     *
     * @param summary the AISummary entity
     * @return SummaryResponse DTO
     */
    private SummaryResponse mapToResponse(AISummary summary) {
        return SummaryResponse.builder()
                .id(summary.getId())
                .audioRecordId(summary.getAudioRecord().getId())
                .content(summary.getContent())
                .structuredData(summary.getStructuredData())
                .tokensUsed(summary.getTokensUsed())
                .model(summary.getModel())
                .createdAt(summary.getCreatedAt())
                .build();
    }
}
